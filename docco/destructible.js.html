<!DOCTYPE html>

<html>
<head>
  <title>destructible.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>

      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page_wrapper">
            <div id="jump_page">


                <a class="source" href="destructible.js.html">
                  destructible.js
                </a>


                <a class="source" href="list.js.html">
                  list.js
                </a>

            </div>
          </div>
        </li>
      </ul>

    <ul class="sections">

          <li id="title">
              <div class="annotation">
                  <h1>destructible.js</h1>
              </div>
          </li>



        <li id="section-1">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <p>Node.js API.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assert&#x27;</span>)</pre></div></div>

        </li>


        <li id="section-2">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Exceptions that you can catch by type.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">const</span> Interrupt = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;interrupt&#x27;</span>)</pre></div></div>

        </li>


        <li id="section-3">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>A Promise wrapper that captures <code>resolve</code> and <code>reject</code>.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">const</span> Future = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;perhaps&#x27;</span>)</pre></div></div>

        </li>


        <li id="section-4">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>A linked-list to track promises, scrams.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">const</span> List = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./list&#x27;</span>)</pre></div></div>

        </li>


        <li id="section-5">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Return the first non-<code>null</code>-like value.</p>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">const</span> coalesce = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;extant&#x27;</span>)</pre></div></div>

        </li>


        <li id="section-6">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-7">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Destructible is a class and instances form a destructible tree. The tree is
not explicit, there is no list of children. There is a parent pointer. It is
only used by the <code>isDestroyedIfDestroyed</code> function.</p>

            </div>

        </li>


        <li id="section-8">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>The children are referenced using the <code>destruct</code> list and the <code>panic</code> list.
There a list of waiting sub-destructibles, but it is a list of destructible
ids only for reporting in the exception.</p>

            </div>

        </li>


        <li id="section-9">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Destructible</span> </span>{</pre></div></div>

        </li>


        <li id="section-10">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-11">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p><strong>TODO</strong> Organize and prune this list.</p>

            </div>

        </li>


        <li id="section-12">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">Error</span> = Interrupt.create(<span class="hljs-string">&#x27;Destructible.Error&#x27;</span>, {
        <span class="hljs-attr">INVALID_TRACER</span>: <span class="hljs-string">&#x27;tracer must be a function that takes a single argument&#x27;</span>,
        <span class="hljs-attr">INVALID_ARGUMENT</span>: <span class="hljs-string">`
            the strand constructor argument must be a function, Promise, initial countdown, or nothing at all
        `</span>,
        <span class="hljs-attr">INVALID_COUNTDOWN</span>: {
            <span class="hljs-attr">code</span>: <span class="hljs-string">&#x27;INVALID_ARGUMENT&#x27;</span>,
            <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;the countdown must be an integer zero or greater, got: %(_countdown)d&#x27;</span>
        },
        <span class="hljs-attr">TRACER_DID_NOT_INVOKE</span>: {
            <span class="hljs-attr">code</span>: <span class="hljs-string">&#x27;INVALID_TRACER&#x27;</span>,
            <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;tracer did not call given function&#x27;</span>
        },
        <span class="hljs-attr">NOT_A_DESTRUCTIBLE</span>: {
            <span class="hljs-attr">code</span>: <span class="hljs-string">&#x27;INVALID_ARGUMENT&#x27;</span>,
            <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;argument must be an instance of Destructible&#x27;</span>
        },
        <span class="hljs-attr">NOT_DEFERRABLE</span>: <span class="hljs-string">&#x27;attempt to increment countdown of a destructible that is not deferrable&#x27;</span>,
        <span class="hljs-attr">DESTROYED</span>: <span class="hljs-string">&#x27;attempt to launch new strands after destruction&#x27;</span>,
        <span class="hljs-attr">EXCEPTIONAL</span>: <span class="hljs-string">&#x27;strand raised an exception&#x27;</span>,
        <span class="hljs-attr">ERRORED</span>: <span class="hljs-string">&#x27;strand exited with exception&#x27;</span>,
        <span class="hljs-attr">SCRAMMED</span>: <span class="hljs-string">&#x27;strand failed to exit or make progress&#x27;</span>,
        <span class="hljs-attr">DURABLE</span>: <span class="hljs-string">&#x27;early exit from a strand expected to last for entire life of destructible&#x27;</span>
    })</pre></div></div>

        </li>


        <li id="section-13">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-14">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Constructor arguments are still in flux. Not sure that the timeout should
be implicit. Wondering if splat functions are technically megaporhic in
Google V8. Probably doesnâ€™t matter though, as Destructibles are created
in frequently and portend an <code>async</code> call which is going to be the
bottleneck. Benchmarking shows that the overhead of creating a
destructible for a an <code>async</code> call to an <code>&#39;fs&#39;</code> function is vanishingly
small.</p>

            </div>

        </li>


        <li id="section-15">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-title">constructor</span> (<span class="hljs-params">...vargs</span>) {
        <span class="hljs-keyword">const</span> $trace = <span class="hljs-keyword">typeof</span> vargs[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;function&#x27;</span> ? vargs.shift() : <span class="hljs-literal">null</span>

        <span class="hljs-keyword">const</span> timeout = <span class="hljs-keyword">typeof</span> vargs[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;number&#x27;</span> ? vargs.shift() : <span class="hljs-number">1000</span>

        <span class="hljs-keyword">const</span> options = {
            $trace, timeout, ...(<span class="hljs-keyword">typeof</span> vargs[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;object&#x27;</span> ? vargs.shift() : {})
        }

        <span class="hljs-built_in">this</span>._timeout = options.timeout

        <span class="hljs-built_in">this</span>.id = vargs.shift()
        assert(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span>.id == <span class="hljs-string">&#x27;string&#x27;</span>)

        <span class="hljs-built_in">this</span>.path = [ <span class="hljs-built_in">this</span>.id ]

        <span class="hljs-built_in">this</span>.destroyed = <span class="hljs-literal">false</span>

        <span class="hljs-built_in">this</span>._ephemeral = <span class="hljs-literal">true</span></pre></div></div>

        </li>


        <li id="section-16">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p><strong>TODO</strong> Where am I really using this? Starting to feel that I should
just use Interrupt to filter specific errors, i.e.
Destructible.DESTROYED, rather than try to filter then when raised.</p>
<p>Any futher reflections on <code>rescue</code>, see <code>rescue</code>.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-built_in">this</span>._properties = <span class="hljs-built_in">Object</span>.defineProperties({}, {
            <span class="hljs-attr">$trace</span>: {
                <span class="hljs-attr">value</span>: <span class="hljs-built_in">this</span>._trace,
            },
            <span class="hljs-attr">instance</span>: {
                <span class="hljs-attr">value</span>: <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;INSTANCE&#x27;</span>),
                <span class="hljs-attr">enumberable</span>: <span class="hljs-literal">false</span>,
                <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>
            }
        })

        <span class="hljs-built_in">this</span>._promise = <span class="hljs-keyword">new</span> Future

        <span class="hljs-built_in">this</span>._done = <span class="hljs-keyword">new</span> Future

        <span class="hljs-built_in">this</span>._parent = <span class="hljs-literal">null</span>

        <span class="hljs-built_in">this</span>.durables = <span class="hljs-number">0</span>

        <span class="hljs-built_in">this</span>.ephemerals = <span class="hljs-number">0</span>

        <span class="hljs-built_in">this</span>._waiting = <span class="hljs-keyword">new</span> List

        <span class="hljs-built_in">this</span>._countdown = <span class="hljs-number">0</span>

        <span class="hljs-built_in">this</span>.deferrable = <span class="hljs-literal">true</span>

        <span class="hljs-built_in">this</span>._scrammable = <span class="hljs-keyword">new</span> List

        <span class="hljs-built_in">this</span>._errors = []</pre></div></div>

        </li>


        <li id="section-17">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Progress is isolated by ephemeral until the parent of the ephemeral
destructs.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-built_in">this</span>._progress = [ <span class="hljs-literal">true</span> ]</pre></div></div>

        </li>


        <li id="section-18">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>Error isolation is specified in a sub-destructible constuctor.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-built_in">this</span>._isolation = { <span class="hljs-attr">errored</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">panic</span>: [] }</pre></div></div>

        </li>


        <li id="section-19">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>Used to flag whether an ephemeral can be created after construction.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-built_in">this</span>._destructing = <span class="hljs-literal">false</span>

        <span class="hljs-built_in">this</span>._destructors = <span class="hljs-keyword">new</span> List

        <span class="hljs-built_in">this</span>._panic = <span class="hljs-keyword">new</span> List

        <span class="hljs-built_in">this</span>._scrams = <span class="hljs-keyword">new</span> List

        <span class="hljs-built_in">this</span>._timer = Future.resolve()

        <span class="hljs-built_in">this</span>._drain = Future.resolve()

        <span class="hljs-built_in">this</span>._tracer = coalesce(options.tracer, { <span class="hljs-attr">push</span>: <span class="hljs-function">() =&gt;</span> {} })

        <span class="hljs-built_in">this</span>._cleanup = []
    }

    get promise () {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._promise.promise
    }

    get done () {
        <span class="hljs-keyword">if</span> (! <span class="hljs-built_in">this</span>._done.fulfilled) {
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._done.promise
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
    }

    get countdown () {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._countdown
    }

    get errored () {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._isolation.errored
    }

    isDestroyedIfDestroyed (destructible) {
        Destructible.Error.assert(destructible <span class="hljs-keyword">instanceof</span> Destructible, <span class="hljs-string">&#x27;NOT_A_DESTRUCTIBLE&#x27;</span>)
        <span class="hljs-keyword">const</span> path = []
        <span class="hljs-keyword">let</span> iterator = <span class="hljs-built_in">this</span>, boundary
        <span class="hljs-keyword">do</span> {
            path.push(iterator)
            boundary = iterator.deferrable
            iterator = iterator._parent
        } <span class="hljs-keyword">while</span> (iterator != <span class="hljs-literal">null</span> &amp;&amp; ! boundary)
        iterator = destructible
        <span class="hljs-keyword">do</span> {
            <span class="hljs-keyword">if</span> (~path.indexOf(iterator)) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
            }
            boundary = iterator.deferrable || iterator._ephemeral
            iterator = iterator._parent
        } <span class="hljs-keyword">while</span> (iterator != <span class="hljs-literal">null</span> &amp;&amp; ! boundary)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    }</pre></div></div>

        </li>


        <li id="section-20">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-21">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>Not going to call the function if already destroyed/errored. Doesnâ€™t seem
to be the case that weâ€™re registering destructors after starup, nor
registering panic after startup except maybe in a destructor. Oh, youâ€™re
kidding me? The list of sub-destructibles is held by the list of
destructors. Way to go, champ.</p>

            </div>

        </li>


        <li id="section-22">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    destruct (f) {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._destructors.push(f)
    }</pre></div></div>

        </li>


        <li id="section-23">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-24">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>Panic always runs when an isolation has errored. It is used to cancel any
queued work and to cancel an ephemeral launched by shutdown.</p>

            </div>

        </li>


        <li id="section-25">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>Relatively certian that it is simple enough for an isolation. When you
destruct, if your isolation is errored, you work the panic list to empty
in <code>destruct</code> after calling, otherwise you push the panic list onto the
list of panic lists for the isolation. If there are any further errors
the catch block awaiting that promise will run the list of panic lists to
empty. This occurs when we destruct normally and then someone
subsequently errors while shutting down, easy to imagine.</p>

            </div>

        </li>


        <li id="section-26">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>Across isolations is where Iâ€™m stuck at the moment, just because I canâ€™t
get wound up about this.</p>

            </div>

        </li>


        <li id="section-27">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>Because I feel okay about isolation panic handling, I can use destruct
and panic to implement propagation.</p>

            </div>

        </li>


        <li id="section-28">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>Isolation means we donâ€™t panic down from the parent but we do panic up to
the parent. Already we donâ€™t errored down, but we do errored up.</p>

            </div>

        </li>


        <li id="section-29">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    panic (f) {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._panic.push(f)
    }</pre></div></div>

        </li>


        <li id="section-30">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-31">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>Used to return the cleared function but had no use for that in practice
and then added the list of handles argument which made the return
polymorphic so forget it. Weâ€™re using lists becase we may have thousands
of handles to clear, do we want thousands of functions returned?</p>

            </div>

        </li>


        <li id="section-32">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>But weâ€™re not doing this really. We may create thousands of
sub-destructibles someday, but not thousands of destructors/panics.</p>

            </div>

        </li>


        <li id="section-33">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    clear (handle) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> handle[<span class="hljs-built_in">Symbol</span>.iterator] == <span class="hljs-string">&#x27;function&#x27;</span>) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> _handle <span class="hljs-keyword">of</span> handle) {
                <span class="hljs-built_in">this</span>.clear(_handle)
            }
        } <span class="hljs-keyword">else</span> {
            List.unlink(handle)
        }
    }</pre></div></div>

        </li>


        <li id="section-34">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-35">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>Internal method for processing the return value when either all monitored
promises have resolved or the shutdown failed to complete before the
scram timeout.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    _return () {
        <span class="hljs-keyword">while</span> (! <span class="hljs-built_in">this</span>._panic.empty) {
            <span class="hljs-built_in">this</span>._panic.shift()
        }
        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">this</span>._cleanup.length != <span class="hljs-number">0</span>) {
            <span class="hljs-built_in">this</span>._cleanup.shift()()
        }
        <span class="hljs-keyword">if</span> (! <span class="hljs-built_in">this</span>._waiting.empty || <span class="hljs-built_in">this</span>._countdown != <span class="hljs-number">0</span>) {
            <span class="hljs-built_in">this</span>._promise.reject(<span class="hljs-keyword">new</span> Destructible.Error(<span class="hljs-string">&#x27;SCRAMMED&#x27;</span>, <span class="hljs-built_in">this</span>._errors, {
                <span class="hljs-attr">id</span>: <span class="hljs-built_in">this</span>.id,
                <span class="hljs-attr">countdown</span>: <span class="hljs-built_in">this</span>._countdown,
                <span class="hljs-attr">waiting</span>: <span class="hljs-built_in">this</span>._waiting.slice()
            }, <span class="hljs-built_in">this</span>._properties))
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>._errors.length != <span class="hljs-number">0</span>) {
            <span class="hljs-built_in">this</span>._promise.reject(<span class="hljs-keyword">new</span> Destructible.Error(<span class="hljs-string">&#x27;ERRORED&#x27;</span>, <span class="hljs-built_in">this</span>._errors, {
                <span class="hljs-attr">id</span>: <span class="hljs-built_in">this</span>.id,
                <span class="hljs-attr">countdown</span>: <span class="hljs-built_in">this</span>._countdown,
                <span class="hljs-attr">waiting</span>: <span class="hljs-built_in">this</span>._waiting.slice()
            }, <span class="hljs-built_in">this</span>._properties))
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-built_in">this</span>._promise.resolve()
        }
        <span class="hljs-built_in">this</span>._done.resolve()
    }</pre></div></div>

        </li>


        <li id="section-36">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>Temporary function to ensure noone is using the cause property.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    get cause () {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>
    }

    operational (additional = <span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.destroyed &amp;&amp; additional) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Destructible.Error(<span class="hljs-string">&#x27;DESTROYED&#x27;</span>, <span class="hljs-built_in">this</span>._properties, { <span class="hljs-attr">path</span>: <span class="hljs-built_in">this</span>.path })
        }
    }</pre></div></div>

        </li>


        <li id="section-37">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-38">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>If we are ephemeral, and the root is always ephemeral, we run a timer and
check for any progress that occurred while we where asleep. Applications
call <code>destructible.progress()</code> that sets a boolean. The boolean is shared
by reference by all the destructibles in an error isolation group.</p>

            </div>

        </li>


        <li id="section-39">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>If we are not ephemeral we add the resolve side of a promise to our list
of scrams and await the resolution of the promise.</p>

            </div>

        </li>


        <li id="section-40">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>When we are done we loop loop through our list of scrammables awaiting
their resolution. They are all going to resolve because either they
finished normally or theyâ€™ve just been scrammed.</p>

            </div>

        </li>


        <li id="section-41">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>We also have a case where we are ephemeral sub-destructible but our
parent has destructed. When this happens our ephemeral state changes to
false and our timer is resolved, so we check our ephemeral state and if
it is no longer ephemeral we return a call to shutdown that will perform
the non-ephemeral wait.</p>

            </div>

        </li>


        <li id="section-42">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">async</span> _shutdown () {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>._ephemeral) {
            assert(! <span class="hljs-built_in">this</span>._waiting.empty)
            <span class="hljs-keyword">let</span> timeout = <span class="hljs-literal">null</span></pre></div></div>

        </li>


        <li id="section-43">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>We got officially scrammed. We set progress to false on the off
chance that it is somehow true so we donâ€™t continue to wait.
Defensive programming.</p>

            </div>

            <div class="content"><div class='highlight'><pre>            <span class="hljs-built_in">this</span>._scrams.push(<span class="hljs-function">() =&gt;</span> {
                <span class="hljs-built_in">this</span>._progress[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>
                <span class="hljs-built_in">clearTimeout</span>(timeout)
                <span class="hljs-built_in">this</span>._timer.resolve()
            })
            <span class="hljs-built_in">this</span>._progress[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>
            <span class="hljs-keyword">while</span> (! <span class="hljs-built_in">this</span>._waiting.empty &amp;&amp; <span class="hljs-built_in">this</span>._progress[<span class="hljs-number">0</span>]) {
                <span class="hljs-built_in">this</span>._progress[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>
                <span class="hljs-built_in">this</span>._timer = <span class="hljs-keyword">new</span> Future
                timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">this</span>._timer.resolve(), <span class="hljs-built_in">this</span>._timeout)
                <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>._timer.promise
                <span class="hljs-keyword">if</span> (! <span class="hljs-built_in">this</span>._ephemeral) {
                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._shutdown()
                }
            }
            <span class="hljs-built_in">this</span>._scram()
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">const</span> future = <span class="hljs-keyword">new</span> Future
            <span class="hljs-built_in">this</span>._scrams.push(<span class="hljs-function">() =&gt;</span> future.resolve())
            <span class="hljs-keyword">await</span> future.promise
        }</pre></div></div>

        </li>


        <li id="section-44">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>Wait for any scrammable promises. Reducing the list is performed on
the resolution side. They will all return now because they have all
been scrammed. Use to be synchrnonous when error-first callback, but
we now have to await the micro-stask queue.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">this</span>._scrammable.empty) {
            <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>._scrammable.peek().promise
        }</pre></div></div>

        </li>


        <li id="section-45">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>Calcuate the resolution of this <code>Destructible</code>.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-built_in">this</span>._return()
    }</pre></div></div>

        </li>


        <li id="section-46">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-47">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p><code>destructible.destroy()</code> &mdash; Destroy the <code>Destructible</code> and
ultimately destroy every <code>Destructible</code> in the tree rooted by the upper
most ephemeral <code>Destructible</code> or the root Destructible if no ephemeral
<code>Destructible</code> exists.</p>
<p>Actually, thatâ€™s an error if the destructible is durable.</p>
<p>We return <code>this</code> so we can call <code>destroy()</code> and await on <code>promise</code> or
<code>done</code> in one line.</p>

            </div>

        </li>


        <li id="section-48">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    _destroy () {</pre></div></div>

        </li>


        <li id="section-49">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>If weâ€™ve not yet been destroyed, letâ€™s start the shutdown.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.destroyed) {</pre></div></div>

        </li>


        <li id="section-50">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>            <span class="hljs-built_in">this</span>.destroyed = <span class="hljs-literal">true</span></pre></div></div>

        </li>


        <li id="section-51">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-52">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>Run our destructors. They are synchronous. If they want to do
something asynchronous they can create an ephemeral while the
destructor is running. That ephemeral can create further
sub-destructibles. Thus, running new sub-destructibles after
destruction takes some determination.</p>

            </div>

        </li>


        <li id="section-53">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>            <span class="hljs-built_in">this</span>._destructing = <span class="hljs-literal">true</span>
            <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">this</span>._destructors.empty) {
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-built_in">this</span>._destructors.shift().call()
                } <span class="hljs-keyword">catch</span> (error) {
                    <span class="hljs-built_in">this</span>._errors.push(<span class="hljs-keyword">new</span> Destructible.Error(<span class="hljs-string">&#x27;DESTROY&#x27;</span>, [ error ], <span class="hljs-built_in">this</span>._properties))
                }
            }
            <span class="hljs-built_in">this</span>._destructing = <span class="hljs-literal">false</span></pre></div></div>

        </li>


        <li id="section-54">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-55">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>If we are errored, now is the time to panic. If not we add our
panic list to the list of panic lists for the isolation.</p>

            </div>

        </li>


        <li id="section-56">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>Any ephemeral created after destruction will be isolated, it will
only enter the errored state if an error occurs in that sub-tree.</p>

            </div>

        </li>


        <li id="section-57">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>._isolation.errored) {
                <span class="hljs-keyword">while</span> (! <span class="hljs-built_in">this</span>._panic.empty) {
                    <span class="hljs-built_in">this</span>._panic.shift()()
                }
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-built_in">this</span>._isolation.panic.push(<span class="hljs-built_in">this</span>._panic)
            }</pre></div></div>

        </li>


        <li id="section-58">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>If weâ€™re complete, we can resolve the <code>Destructible.promise</code>,
otherwise we need to wait for the scram timer.</p>

            </div>

        </li>


        <li id="section-59">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>._complete()) {
                <span class="hljs-built_in">this</span>._return()
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-built_in">this</span>._shutdown()
            }
       }
    }

    destroy () {
        <span class="hljs-built_in">this</span>._tracer.push({ <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;destroy&#x27;</span>, <span class="hljs-attr">errored</span>: <span class="hljs-built_in">this</span>._isolation.errored, <span class="hljs-attr">path</span>: <span class="hljs-built_in">this</span>.path  })
        <span class="hljs-built_in">this</span>._countdown = <span class="hljs-number">0</span>
        <span class="hljs-built_in">this</span>._destroy()
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>
    }</pre></div></div>

        </li>


        <li id="section-60">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-61">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p><strong>TODO</strong> For documentation, this is a new convention. Drain returns a
<code>Promise</code> if something is awaiting <code>null</code> otherwise. Allows to
synchornously do nothing and know you did nothing.</p>

            </div>

        </li>


        <li id="section-62">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p>An ephemeral could be added after the drain promise is resolved but
before the drain function continues. Not really a race condition. We
could simply await the drain. Drain is only ever used to ensure that a
particular write flushed, or work in a work queue completed, that
progress was made past a certian point or alternatively, that everything
has shut down. Although, in the shutdown case, we do have a race unless
weâ€™re certain that, well we have to be certain that new ephemerals are
only created by ephemerals, you donâ€™t use drain to test done.</p>

            </div>

        </li>


        <li id="section-63">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    drain () {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.ephemerals != <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">async</span> () =&gt; {
                <span class="hljs-keyword">while</span> (<span class="hljs-built_in">this</span>.ephemerals != <span class="hljs-number">0</span>) {
                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>._drain.fulfilled) {
                        <span class="hljs-built_in">this</span>._drain = <span class="hljs-keyword">new</span> Future
                    }
                    <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>._drain.promise
                }
            }) ()
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
    }</pre></div></div>

        </li>


        <li id="section-64">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p>TODO Now with operative we might want to have another property for this
countdown, which we might call countdown, and if it is never set to
anything it is ignored.</p>

            </div>

        </li>


        <li id="section-65">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <p>Increment a countdown to destruction. Calling <code>increment()</code> increments an
internal counter. Calling <code>decrement()</code> decrements the internal counter.
When the counter reaches zero, the <code>Destructible</code> is destroyed. If you do
not call <code>increment</code> or <code>decrement</code> it has no effect on the
<code>Destructible</code>. After calling <code>increment</code> you can still call <code>destroy()</code>
to explicit and immediately destroy the <code>Destructible</code>. The completion of
a durable <code>Promise</code> will also explicitly and immediately destroy the
<code>Destructible</code>.</p>

            </div>

        </li>


        <li id="section-66">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    increment () {
        Destructible.Error.assert(<span class="hljs-built_in">this</span>.deferrable, <span class="hljs-string">&#x27;NOT_DEFERRABLE&#x27;</span>, { <span class="hljs-attr">id</span>: <span class="hljs-built_in">this</span>.id })
        <span class="hljs-built_in">this</span>._tracer.push({
            <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;increment&#x27;</span>,
            <span class="hljs-attr">errored</span>: <span class="hljs-built_in">this</span>._isolation.errored,
            <span class="hljs-attr">countdown</span>: <span class="hljs-built_in">this</span>._countdown,
            <span class="hljs-attr">path</span>: <span class="hljs-built_in">this</span>.path
        })
        <span class="hljs-built_in">this</span>._countdown++
    }

    decrement () {
        <span class="hljs-built_in">this</span>._tracer.push({
            <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;decrement&#x27;</span>,
            <span class="hljs-attr">errored</span>: <span class="hljs-built_in">this</span>._isolation.errored,
            <span class="hljs-attr">countdown</span>: <span class="hljs-built_in">this</span>._countdown,
            <span class="hljs-attr">path</span>: <span class="hljs-built_in">this</span>.path
        })
        Destructible.Error.assert(<span class="hljs-built_in">this</span>.deferrable, <span class="hljs-string">&#x27;NOT_DEFERRABLE&#x27;</span>, { <span class="hljs-attr">id</span>: <span class="hljs-built_in">this</span>.id })
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>._countdown == <span class="hljs-number">0</span>) {
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (--<span class="hljs-built_in">this</span>._countdown == <span class="hljs-number">0</span>) {
            <span class="hljs-built_in">this</span>._destroy()
        }
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>
    }</pre></div></div>

        </li>


        <li id="section-67">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <p>We keep this as an array of functions, as opposed to an array of
children, because we push a scram timer canceller or forever waiter onto
the end of the array of scrams. Seems like we could just keep the
canceller/waiter as a separate variable, for when we <code>_complete</code>, but it
may also be the case that weâ€™re an ephemeral destructible waiting on a
our own scram, when our parent, with a shorter timeout scrams. Now
<code>_scram</code> will scram all our children and tell us to to stop waiting.
<code>_complete</code> will only ever tell us to stop waiting because all our
children will have completed.</p>

            </div>

        </li>


        <li id="section-68">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    _scram () {</pre></div></div>

        </li>


        <li id="section-69">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <p>TODO New stuff, come back and rewrite when itâ€™s old stuff. We get
told to scram, but weâ€™ve not destroyed. That means that someone
created a child destructible that they needed to stay alive after the
parent is destroyed â€” the parent can write to services in the child
that would attempt to create a new <code>ephemeral</code> and error.</p>
<p>Now that <code>destroy</code> is synchronous, when we call it, it will call
destroy on all children and it will synchronously build a scram chain
so that the next call to run our scrams will propagate scrams.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (! <span class="hljs-built_in">this</span>.destroyed) {
            <span class="hljs-built_in">this</span>._destroy()
        }
        <span class="hljs-keyword">while</span> (! <span class="hljs-built_in">this</span>._scrams.empty) {
            <span class="hljs-built_in">this</span>._scrams.shift()()
        }
    }</pre></div></div>

        </li>


        <li id="section-70">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <p>Check to see if this <code>Destructible</code> has completed its shutdown if it is
destroyed. If the destructible has completed the call to scran does not
actually scram, it just wakes up the scram timer.</p>

            </div>

            <div class="content"><div class='highlight'><pre>    _complete () {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.destroyed &amp;&amp; <span class="hljs-built_in">this</span>._waiting.empty) {
            <span class="hljs-built_in">this</span>._scram()
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
        }
    }</pre></div></div>

        </li>


        <li id="section-71">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <p>This is becoming increasingly dubious. Iâ€™ve never used it. Might be
better to just return the result of <code>durable</code> or <code>ephemeral</code> if thatâ€™s
what you want, but uh, no. That doesnâ€™t make sense, oh, no it does, itâ€™s
pretty much the same thing, this is the result of <code>durable</code>.</p>
<p><strong>TODO</strong> Exceedingly dubious and I donâ€™t want to document it.</p>
<pre><code><span class="hljs-keyword">const</span> result = {
    <span class="hljs-attr">first</span>: <span class="hljs-keyword">await</span> destructble(<span class="hljs-string">&#x27;first&#x27;</span>, <span class="hljs-built_in">this</span>._first()),
    <span class="hljs-attr">second</span>: <span class="hljs-keyword">await</span> destructible(<span class="hljs-string">&#x27;second&#x27;</span>, <span class="hljs-built_in">this</span>._second()),
}
<span class="hljs-keyword">await</span> destructible.rejected
<span class="hljs-keyword">return</span> result</code></pre>
<p>How is that any different? Not the result of <code>rejected</code>, but still.</p>

            </div>

        </li>


        <li id="section-72">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-73">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-73">&#182;</a>
              </div>
              <p>The <code>_scrams</code> array is an array of functions that call the <code>_scram</code> of a
destructible, while the <code>_scrammable</code> array is an array of semaphores
that blocks a parent <code>Destructible</code> from resolving a scram timeout.</p>
<p>We need to remove the scram function from <code>_scrams</code> immediately, before
we call destroy, which is why have it crowded in here instead of our our
<code>_awaitScrammable</code> wrapper. We donâ€™t have <code>_scammable</code> management in here
because it would just mean two extra <code>if</code> statements when we already
know.</p>

            </div>

            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">async</span> _awaitPromise (operation, errored, wait, properties) {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> operation
            } <span class="hljs-keyword">finally</span> {
                List.unlink(wait)
            }
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-keyword">if</span> (error <span class="hljs-keyword">instanceof</span> Destructible.Error &amp;&amp; error.symbol != Destructible.Error.DESTROYED) {
                <span class="hljs-built_in">this</span>._errors.push(error)
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-built_in">this</span>._errors.push(<span class="hljs-keyword">new</span> Destructible.Error(properties, { <span class="hljs-attr">$stack</span>: <span class="hljs-number">0</span> }, <span class="hljs-string">&#x27;ERRORED&#x27;</span>, [ error ], wait.value))
            }</pre></div></div>

        </li>


        <li id="section-74">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-74">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>            <span class="hljs-built_in">this</span>._isolation.errored = <span class="hljs-literal">true</span></pre></div></div>

        </li>


        <li id="section-75">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-75">&#182;</a>
              </div>
              <p>Isolation list of panic lists is populated at destruction, so
this panics anything in our isolation that has already
destructed.</p>

            </div>

            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">while</span> (<span class="hljs-built_in">this</span>._isolation.panic.length != <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">const</span> panic = <span class="hljs-built_in">this</span>._isolation.panic.shift()
                <span class="hljs-keyword">while</span> (! panic.empty) {
                    panic.shift()()
                }
            }</pre></div></div>

        </li>


        <li id="section-76">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-76">&#182;</a>
              </div>
              <p>This will send destruction and panic up to our ephemeral and it
will send it down to everyone in our isolation.</p>

            </div>

            <div class="content"><div class='highlight'><pre>            <span class="hljs-built_in">this</span>._tracer.push({ <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;promise&#x27;</span>, <span class="hljs-attr">errored</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">path</span>: <span class="hljs-built_in">this</span>.path })
            <span class="hljs-built_in">this</span>._countdown = <span class="hljs-number">0</span>
            <span class="hljs-built_in">this</span>._destroy()
            <span class="hljs-keyword">return</span> errored
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">switch</span> (wait.value.method) {
            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;durable&#x27;</span>: {
                    <span class="hljs-built_in">this</span>.durables--
                    <span class="hljs-keyword">if</span> (! <span class="hljs-built_in">this</span>.destroyed) {
                        <span class="hljs-built_in">this</span>._isolation.errored = <span class="hljs-literal">true</span>
                        <span class="hljs-built_in">this</span>._errors.push(<span class="hljs-keyword">new</span> Destructible.Error(properties, <span class="hljs-string">&#x27;DURABLE&#x27;</span>, wait.value))
                        <span class="hljs-built_in">this</span>._tracer.push({ <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;durable&#x27;</span>, <span class="hljs-attr">errored</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">path</span>: <span class="hljs-built_in">this</span>.path })
                        <span class="hljs-built_in">this</span>._countdown = <span class="hljs-number">0</span>
                        <span class="hljs-built_in">this</span>._destroy()
                    }
                }
                <span class="hljs-keyword">break</span>
            <span class="hljs-attr">default</span>: {
                    <span class="hljs-keyword">if</span> (--<span class="hljs-built_in">this</span>.ephemerals == <span class="hljs-number">0</span>) {
                        <span class="hljs-built_in">this</span>._drain.resolve()
                    }
                }
                <span class="hljs-keyword">break</span>
            }
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.destroyed) {
                <span class="hljs-built_in">this</span>._complete()
            }
        }
    }</pre></div></div>

        </li>


        <li id="section-77">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-77">&#182;</a>
              </div>
              <p>Await the promise of a sub-destructible. We know that a sub-destructible
will always resolve due to our scram logic, so we maintain a list of
scrammable futures for the parent to wait for after it has been notified
of a scram timeout. See scram logic above for more details.</p>

            </div>

        </li>


        <li id="section-78">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-78">&#182;</a>
              </div>
              <p>Here we are creating a block that is protected by a <code>Promise</code>. We want to
wait for the <code>operation</code>, but we donâ€™t want to wait on the <code>operation</code>
because itâ€™s not ours and it may reject, so we create a tracking
<code>Promise</code>. We should probably rename <code>_scrams</code> to <code>_children</code>.</p>
<p>Separate function because the promise is fire and forget, we donâ€™t wait
for it in <code>_await</code> and <code>_await</code> needs to return the <code>Destructible</code> it
creates.</p>

            </div>

        </li>


        <li id="section-79">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-79">&#182;</a>
              </div>
              <p><strong>TODO</strong> Weâ€™re going to have race conditions if we do not push the
scrammable in the same synchronous run in which we check destroyed. (This
is getting to be an old TODO. Wondering how to examine my assumptions
about this. I believe this has to do with being concerned about the
construction location of the promise and the push, can we be assured that
we enter <code>async</code> functions synchronously? Experience tells me this is the
case in Google V8, but is it specified in the ECMA standard?)</p>

            </div>

        </li>


        <li id="section-80">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-80">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">async</span> _awaitScrammable (destructible, wait, scram) {</pre></div></div>

        </li>


        <li id="section-81">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-81">&#182;</a>
              </div>
              <p>Monitor our new destructible as child of this destructible.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">const</span> scrammable = <span class="hljs-keyword">new</span> Future
        <span class="hljs-keyword">const</span> node = <span class="hljs-built_in">this</span>._scrammable.push(scrammable)
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>._awaitPromise(destructible.promise, <span class="hljs-literal">null</span>, wait, {})
        } <span class="hljs-keyword">finally</span> {</pre></div></div>

        </li>


        <li id="section-82">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-82">&#182;</a>
              </div>
              <p>TODO Convince yourself that it doensâ€™t matter if you call a
scrammable before you call <code>_complete</code>.</p>

            </div>

            <div class="content"><div class='highlight'><pre>            List.unlink(scram)
            List.unlink(node)
            scrammable.resolve()
        }
    }

    _await (method, vargs) {
        <span class="hljs-keyword">if</span> (!(<span class="hljs-built_in">this</span>._destructing &amp;&amp; method == <span class="hljs-string">&#x27;ephemeral&#x27;</span>)) {
            <span class="hljs-built_in">this</span>.operational()
        }
        <span class="hljs-keyword">const</span> options = {
            <span class="hljs-attr">$trace</span>: <span class="hljs-keyword">typeof</span> vargs[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;function&#x27;</span> ? vargs.shift() : <span class="hljs-literal">null</span>,
            <span class="hljs-attr">timeout</span>: <span class="hljs-keyword">typeof</span> vargs[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;number&#x27;</span> ? vargs.shift() : <span class="hljs-built_in">this</span>._timeout,
            ...(<span class="hljs-keyword">typeof</span> vargs[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;object&#x27;</span> ? vargs.shift() : {}),
            <span class="hljs-attr">id</span>: vargs.shift()
        }
        assert(<span class="hljs-keyword">typeof</span> options.id == <span class="hljs-string">&#x27;string&#x27;</span>)
        <span class="hljs-keyword">const</span> wait = <span class="hljs-built_in">this</span>._waiting.push({ method, <span class="hljs-attr">id</span>: options.id })</pre></div></div>

        </li>


        <li id="section-83">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-83">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-84">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-84">&#182;</a>
              </div>
              <p>If a function, invoke it it and await the result as a promise, if no
arguments it is a sub-destructible, treat anything else as a promise,
it will get wrapped by <code>async</code> if it is not a promise already.</p>

            </div>

        </li>


        <li id="section-85">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-85">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> vargs[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;function&#x27;</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._awaitPromise(vargs.shift()(), coalesce(vargs.shift()), wait, { <span class="hljs-attr">$trace</span>: options.$trace })
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vargs.length == <span class="hljs-number">0</span>) {</pre></div></div>

        </li>


        <li id="section-86">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-86">&#182;</a>
              </div>
              <p>Construct our destructible with the options, then poke into it to
make it a sub-destructible.</p>

            </div>

            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">const</span> destructible = <span class="hljs-keyword">new</span> Destructible(options, options.id)

            destructible._tracer = <span class="hljs-built_in">this</span>._tracer

            destructible.path = <span class="hljs-built_in">this</span>.path.concat(options.id)</pre></div></div>

        </li>


        <li id="section-87">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-87">&#182;</a>
              </div>
              <p>If the caller provided a countdown, we are a deferred
destructible.</p>

            </div>

            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">const</span> deferrable = options.countdown != <span class="hljs-literal">null</span>
            <span class="hljs-keyword">const</span> countdown = deferrable ? options.countdown : <span class="hljs-number">0</span>
            Destructible.Error.assert(<span class="hljs-built_in">Number</span>.isInteger(countdown) &amp;&amp; countdown &gt;= <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;INVALID_COUNTDOWN&#x27;</span>, { <span class="hljs-attr">_countdown</span>: countdown })
            destructible._countdown = countdown
            destructible.deferrable = deferrable</pre></div></div>

        </li>


        <li id="section-88">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-88">&#182;</a>
              </div>
              <p>Inherit the instance symbol, common to the entire destructible
tree.</p>

            </div>

            <div class="content"><div class='highlight'><pre>            <span class="hljs-built_in">Object</span>.defineProperty(destructible._properties, <span class="hljs-string">&#x27;instance&#x27;</span>, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(<span class="hljs-built_in">this</span>._properties, <span class="hljs-string">&#x27;instance&#x27;</span>))</pre></div></div>

        </li>


        <li id="section-89">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-89">&#182;</a>
              </div>
              <p>Set error isolation. Sub-destructibles created during <code>destruct</code>
are error isolated.</p>

            </div>

            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (! options.isolated &amp;&amp; ! <span class="hljs-built_in">this</span>._isolation.errored) {
                destructible._isolation = <span class="hljs-built_in">this</span>._isolation
            }</pre></div></div>

        </li>


        <li id="section-90">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-90">&#182;</a>
              </div>
              <p>Are we ephemeral? If so we get our own progress marker.</p>

            </div>

            <div class="content"><div class='highlight'><pre>            destructible._ephemeral = method == <span class="hljs-string">&#x27;ephemeral&#x27;</span>
            <span class="hljs-keyword">if</span> (destructible._ephemeral) {
                destructible._progress = [ <span class="hljs-literal">true</span> ]
            }</pre></div></div>

        </li>


        <li id="section-91">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-91">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-92">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-92">&#182;</a>
              </div>
              <p>Parent down to leaf destructor path. Destructors run
synchronously so all the associated state is set atomically.</p>
<p>Destroy the child destructible when we are destroyed. Becasue
this destructible is destroyed, it or an ancestor will run a
shutdown timer and the child will defer to that shutdown timer.</p>
<p>Even if the child is deferrable, when it destructs it is not
going to run its own shutdown timer so we tell it that it is no
longer ephemeral. Truely, itâ€™s state has switched from ephemeral
for durable because it will no longer be able to shutdown before
the parent shuts down because the parent has already shutdown.</p>
<p>We do not destroy deferrables with an outstanding countdown.
Asking if the childâ€™s isolation is errored is akin to aksing if
the child is a memember of the parentâ€™s isolation. Think about
it.</p>
<p><strong>TODO</strong> Wait? We are destructing. Destruction stops at
deferrable boundaries not error isolation boundaries. The child
is still destroyed, it is just not errored.</p>
<p>Gotta think use case. Database service. Server service errors so
all of them are panicing, shutting down as hard as possible, but
the database service still can perform its orderly shutdown.</p>
<p>But, if the boundary is both deferrable and isolated, we donâ€™t
destroy it on panic.</p>
<p>Ergo, if we do not destroy the child for any reason, we will
destory the child if we panic and the child is a member of our
isolation.</p>

            </div>

        </li>


        <li id="section-93">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-93">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">const</span> downward = <span class="hljs-built_in">this</span>.destruct(<span class="hljs-function">() =&gt;</span> {
                destructible._ephemeral = <span class="hljs-literal">false</span>
                destructible._progress = <span class="hljs-built_in">this</span>._progress
                <span class="hljs-keyword">if</span> (destructible._countdown == <span class="hljs-number">0</span> || destructible._isolation.errored) {
                    <span class="hljs-built_in">this</span>._tracer.push({
                        <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;downward&#x27;</span>,
                        <span class="hljs-attr">errored</span>: <span class="hljs-built_in">this</span>._isolation.errored,
                        <span class="hljs-attr">path</span>: destructible.path
                    })
                    destructible._countdown = <span class="hljs-number">0</span>
                    destructible._destroy()
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (destructible._isolation === <span class="hljs-built_in">this</span>._isolation) {
                    <span class="hljs-keyword">const</span> panic = <span class="hljs-built_in">this</span>.panic(<span class="hljs-function">() =&gt;</span> {
                        <span class="hljs-built_in">this</span>._tracer.push({
                            <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;panic&#x27;</span>,
                            <span class="hljs-attr">errored</span>: <span class="hljs-built_in">this</span>._isolation.errored,
                            <span class="hljs-attr">path</span>: destructible.path
                        })
                        destructible._countdown = <span class="hljs-number">0</span>
                        destructible._destroy()
                    })
                    destructible._cleanup.push(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">this</span>.clear(panic))
                }
            })</pre></div></div>

        </li>


        <li id="section-94">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-94">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-95">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-95">&#182;</a>
              </div>
              <p>Child up to parent destructor path.</p>

            </div>

        </li>


        <li id="section-96">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-96">&#182;</a>
              </div>
              <p>If we encounter an error after destruction we want to be sure to
destroy the sub-destructible if it is not isolated.</p>

            </div>

        </li>


        <li id="section-97">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-97">&#182;</a>
              </div>
              <p>Clear the downward destructor. If the sub-destructible is durable
or errored we propagate the destruction.</p>

            </div>

        </li>


        <li id="section-98">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-98">&#182;</a>
              </div>
              <p>If the sub-destructible is ephemeral we register a new destructor
that will tell the ephemeral to surrender its scram timer and
allow the parent ephemeral to oversee the scram. When the timer
wakes it will check ephemeral before it checks progress.</p>

            </div>

        </li>


        <li id="section-99">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-99">&#182;</a>
              </div>
              <p><strong>TODO</strong> Is there a progress/ephemeral race? Can we set
destructible while at the same time calling scram for the last
time so that the destructible goes into wait-on-parent-scram when
the parent has already exited? (Doubtful. Tired.)</p>

            </div>

        </li>


        <li id="section-100">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-100">&#182;</a>
              </div>
              <p>If the child is not in our isolation and it panics, we want to
panic. Errors and panics propagate upward.</p>

            </div>

        </li>


        <li id="section-101">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-101">&#182;</a>
              </div>
              <p>If the child is not in our isolation we do not propagate our
panic downward. If it is in our isolation it will share our
panic.</p>

            </div>

        </li>


        <li id="section-102">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-102">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>            destructible.destruct(<span class="hljs-function">() =&gt;</span> {
                <span class="hljs-built_in">this</span>.clear(downward)
                <span class="hljs-keyword">if</span> (destructible._ephemeral &amp;&amp; ! destructible._isolation.errored) {
                    <span class="hljs-keyword">const</span> destruct = <span class="hljs-built_in">this</span>.destruct(<span class="hljs-function">() =&gt;</span> {
                        destructible._ephemeral = <span class="hljs-literal">false</span>
                        destructible._progress = <span class="hljs-built_in">this</span>._progress
                        destructible._timer.resolve()
                    })
                    destructible._cleanup.push(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">this</span>.clear(destruct))
                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>._isolation !== destructible._isolation) {
                        <span class="hljs-keyword">const</span> panic = destructible.panic(<span class="hljs-function">() =&gt;</span> {
                            <span class="hljs-built_in">this</span>._isolation.errored = <span class="hljs-literal">true</span>
                            <span class="hljs-keyword">while</span> (<span class="hljs-built_in">this</span>._isolation.panic.length != <span class="hljs-number">0</span>) {
                                <span class="hljs-keyword">const</span> panic = <span class="hljs-built_in">this</span>._isolation.panic.shift()
                                <span class="hljs-keyword">while</span> (! panic.empty) {
                                    panic.shift()()
                                }
                            }
                        })
                        destructible._cleanup.push(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">this</span>.clear(panic))
                    }
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-built_in">this</span>._isolation.errored = <span class="hljs-built_in">this</span>._isolation.errored || destructible._isolation.errored
                    <span class="hljs-keyword">if</span> (! <span class="hljs-built_in">this</span>.destroyed) {
                        <span class="hljs-keyword">if</span> (! destructible._ephemeral &amp;&amp; ! destructible._isolation.errored) {
                            <span class="hljs-built_in">this</span>._isolation.errored = <span class="hljs-literal">true</span>
                            <span class="hljs-built_in">this</span>._errors.push(<span class="hljs-keyword">new</span> Destructible.Error({ <span class="hljs-attr">$trace</span>: options.$trace }, <span class="hljs-string">&#x27;DURABLE&#x27;</span>, wait.value))
                        }
                        <span class="hljs-built_in">this</span>._tracer.push({
                            <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;upward&#x27;</span>,
                            <span class="hljs-attr">errored</span>: <span class="hljs-built_in">this</span>._isolation.errored,
                            <span class="hljs-attr">path</span>: <span class="hljs-built_in">this</span>.path
                        })
                        <span class="hljs-built_in">this</span>._countdown = <span class="hljs-number">0</span>
                        <span class="hljs-built_in">this</span>._destroy()
                    }
                }
            })</pre></div></div>

        </li>


        <li id="section-103">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-103">&#182;</a>
              </div>
              <p>Scram the child destructible if we are scrammed. Cancel our scram
forwarding if the childâ€™s <code>_scrams</code> unlatches. (A <code>Destructible</code>
will  unlatch<code>_scrams</code> when it completes normally and no scram is
necessary.) Note that we canâ€™t use <code>Promise</code>s because <code>then</code> is
not cancellable, but <code>Signal.wait()</code> is. If we used
<code>Promise.then</code>, then a long-running, like a server, would have an
ever growing list of callbacks for a short-term child, like a
socket connection.</p>

            </div>

        </li>


        <li id="section-104">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-104">&#182;</a>
              </div>
              <p>Propagate scram cancelling propagation if child exits.</p>

            </div>

            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">const</span> scram = <span class="hljs-built_in">this</span>._scrams.push(<span class="hljs-function">() =&gt;</span> {
                destructible._scram()
            })</pre></div></div>

        </li>


        <li id="section-105">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-105">&#182;</a>
              </div>
              <p>This is added at a late date to propagate the progress flag.
Until now, all parent/child communication was done through
generalized structures so that the parent or child was just
another consumer of child or parent services respectively.
Temptation is to rethink whether this should be the case or if
more parent/child interation should be explicit, but rather than
give it a lot of thought, Iâ€™m going to assume that if I did, Iâ€™d
realize that this is the way itâ€™s supposed to be.</p>

            </div>

        </li>


        <li id="section-106">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-106">&#182;</a>
              </div>
              <p>I now depend on this to determine if two destructibles are part
of the same stage.</p>

            </div>

            <div class="content"><div class='highlight'><pre>            destructible._parent = <span class="hljs-built_in">this</span>

            <span class="hljs-built_in">this</span>._awaitScrammable(destructible, wait, scram)

            <span class="hljs-keyword">return</span> destructible
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._awaitPromise(vargs.shift(), coalesce(vargs.shift()), wait, { <span class="hljs-attr">$trace</span>: options.$trace })
        }
    }

    progress () {
        <span class="hljs-built_in">this</span>._progress[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>
    }

    durable (...vargs) {
        <span class="hljs-built_in">this</span>.durables++
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._await(<span class="hljs-string">&#x27;durable&#x27;</span>, vargs)
    }</pre></div></div>

        </li>


        <li id="section-107">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-107">&#182;</a>
              </div>
              <p><code>async ephemeral(id, [ Promise ])</code> &mdash; Start a strand that does not
last the lifetime of the <code>Destructible</code>. Only if the <code>Promise</code> rejects do
we perform an orderly shutdown of the <code>Destructible</code>. No exception is
raised if the <code>Promise</code> of strand rejects.</p>
<p>The <code>id</code> identifies the strand. It can be any JSON serializable object.
It is displayed in the stack trace on error. When creating a sub-group
the <code>id</code> available as a property of the returned <code>Destructible</code>. The <code>id</code>
is not required by <code>durable</code> to be unique. It is for your reference.</p>
<p>This is used for background tasks that are short-term, like shuffling
files around in a database, or indefinate, like chatting on a socket in a
server where there are many sockets opening and closing whenever.</p>
<p>Note that if you have an application like a server where sockets can
raise exceptions that destroy the socket but should not destroy the
server, then you should catch those exceptions in the socket strand.
Destructible has no facilities for rescuing exceptions. It treats any
exception as fatal. Catch blocks in you strands perform rescues.</p>

            </div>

        </li>


        <li id="section-108">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-108">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    ephemeral (...vargs) {
        <span class="hljs-built_in">this</span>.ephemerals++
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._await(<span class="hljs-string">&#x27;ephemeral&#x27;</span>, vargs)
    }

    _vargs (vargs) {
        <span class="hljs-keyword">const</span> $trace = <span class="hljs-keyword">typeof</span> vargs[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;function&#x27;</span> ? vargs.shift() : <span class="hljs-literal">null</span>
        <span class="hljs-keyword">const</span> id = vargs.shift()
        <span class="hljs-keyword">const</span> f = vargs.pop()
        <span class="hljs-keyword">return</span> { $trace, id, f, <span class="hljs-attr">errored</span>: vargs }
    }</pre></div></div>

        </li>


        <li id="section-109">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-109">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-110">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-110">&#182;</a>
              </div>
              <p>Starts to appear dubious when we always panic. If we always panic we can
cancel our orderly shutdown in the panic, but I still see value in not
performing actions at <code>destruct</code> if we are <code>errored</code> because there is
value in not generating additional <code>DESTROYED</code> errors when you know
that <code>errored</code> is likely and if so a <code>DESTROYED</code> is certian.</p>

            </div>

        </li>


        <li id="section-111">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-111">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    copacetic (...vargs) {
        <span class="hljs-keyword">if</span> (! <span class="hljs-built_in">this</span>.errored) {
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.destructive.apply(<span class="hljs-built_in">this</span>, vargs)
        }
        <span class="hljs-keyword">const</span> { errored } = <span class="hljs-built_in">this</span>._vargs(vargs)
        <span class="hljs-keyword">if</span> (errored.length == <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">return</span> errored[<span class="hljs-number">0</span>]
        }
    }

    <span class="hljs-keyword">async</span> _destructive ($trace, promise, id, errored) {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> promise
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">this</span>._isolation.errored = <span class="hljs-literal">true</span>
            <span class="hljs-built_in">this</span>._errors.push(<span class="hljs-keyword">new</span> Destructible.Error({ $trace, <span class="hljs-attr">$stack</span>: <span class="hljs-number">0</span> }, [ error ], <span class="hljs-string">&#x27;ERRORED&#x27;</span>, { <span class="hljs-attr">id</span>: id }))
            <span class="hljs-built_in">this</span>._tracer.push({ <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;destructive&#x27;</span>, <span class="hljs-attr">path</span>: <span class="hljs-built_in">this</span>.path })
            <span class="hljs-built_in">this</span>._countdown = <span class="hljs-number">0</span>
            <span class="hljs-built_in">this</span>._destroy()
            <span class="hljs-keyword">if</span> (errored.length == <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">throw</span> error
            }
            <span class="hljs-keyword">return</span> errored[<span class="hljs-number">0</span>]
        }
    }</pre></div></div>

        </li>


        <li id="section-112">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-112">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-113">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-113">&#182;</a>
              </div>
              <p>Naming these things is dubious and makes the code start to look to
chatty. Do we really need the trace? Because if not we can get rid of the
name. Also, Iâ€™m not really using this except with <code>copacetic</code>, so ever
more dubious. Pay attention to your stack traces and if they really do
look better in Node.js 14 you can lose the names and the <code>$trace</code>.</p>

            </div>

        </li>


        <li id="section-114">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-114">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    destructive (...vargs) {
        <span class="hljs-keyword">const</span> { $trace, id, f, errored } = <span class="hljs-built_in">this</span>._vargs(vargs)
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">let</span> result = f
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> result == <span class="hljs-string">&#x27;function&#x27;</span>) {
                result = result()
            }
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> result.then == <span class="hljs-string">&#x27;function&#x27;</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._destructive($trace, result, id, errored)
            }
            <span class="hljs-keyword">return</span> result
        } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">this</span>._isolation.errored = <span class="hljs-literal">true</span>
            <span class="hljs-built_in">this</span>._errors.push(<span class="hljs-keyword">new</span> Destructible.Error({ $trace, <span class="hljs-attr">$stack</span>: <span class="hljs-number">0</span> }, [ error ], <span class="hljs-string">&#x27;ERRORED&#x27;</span>, { <span class="hljs-attr">id</span>: id }))
            <span class="hljs-built_in">this</span>._tracer.push({ <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;destructive&#x27;</span>, <span class="hljs-attr">path</span>: <span class="hljs-built_in">this</span>.path })
            <span class="hljs-built_in">this</span>._countdown = <span class="hljs-number">0</span>
            <span class="hljs-built_in">this</span>._destroy()
            <span class="hljs-keyword">if</span> (errored.length == <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">throw</span> error
            }
            <span class="hljs-keyword">return</span> errored[<span class="hljs-number">0</span>]
        }
    }

    copacetic2 (f, ...vargs) {
        <span class="hljs-keyword">if</span> (! <span class="hljs-built_in">this</span>.errored) {
            <span class="hljs-keyword">return</span> f()
        }
        <span class="hljs-keyword">if</span> (vargs.length != <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> vargs[<span class="hljs-number">0</span>]
        }
    }</pre></div></div>

        </li>


        <li id="section-115">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-115">&#182;</a>
              </div>

            </div>

        </li>


        <li id="section-116">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-116">&#182;</a>
              </div>
              <p>Addresses an ongoing conceptual problem. Originally encountered during
initialization, but I seem to have forgotten and neglected to really
detail those conditions. The crux was that something went wrong in the
background and that was the real error, but the foreground needed to
stop initializing, stop creating new sub-destructibles, so we threw the
<code>DESTROYED</code> error. It probably bothered me that there was this additional
error in addition to the real error, but that doesnâ€™t bother me any
longer.</p>

            </div>

        </li>


        <li id="section-117">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-117">&#182;</a>
              </div>
              <p>The idea was that if the Destructible was destroyed during initialization
there is probably a real error somewhere so you can ignore <code>DESTROYED</code>.
Callers external to Destructible need <code>DESTROYED</code> so they will curl up
and die, but our initializer just needs to eject.</p>

            </div>

        </li>


        <li id="section-118">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-118">&#182;</a>
              </div>
              <p>Now encountered during unit testing. I was using function for the body of
the test and had a test fail mysterious with no error. The error was that
my service was closing its Destructible prematurely. This is actually a
common error while youâ€™re sorting out the destruction of your service.
Swallowing that error is bewildering. Easy enough to call my unit tests
with an <code>ephemeral</code>, though.</p>

            </div>

        </li>


        <li id="section-119">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-119">&#182;</a>
              </div>
              <p>Which makes this function appear dubious, but it still probably has a
purpose. There is that case of the server with 10,000 sockets open
furiously handling requests and when they handle a request they launch
and <code>ephemeral</code>. A couple thousand fail at once because the database
service has errored and initiated destruction. Now we have to find the
real exception amid a sea of <code>DESTROYED</code> exceptions.</p>

            </div>

        </li>


        <li id="section-120">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-120">&#182;</a>
              </div>
              <p>Now consdiering having a static <code>Interrupt.prune()</code> which would remove
prune branches where all the leaves match a particular pattern, but that
would still run into the problem swallowing a <code>DESTROYED</code> error where the
real problem is that there was a premature non-error shutdown.</p>

            </div>

        </li>


        <li id="section-121">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-121">&#182;</a>
              </div>
              <p>Havenâ€™t built a server with this version of Destructible, so wonâ€™t know
until I try, but I am now assuming that we either have a <code>recoverable</code>
method that is an <code>ephemeral</code> that throws. Weâ€™d launch a <code>recoverable</code>
and then log the exceptions individually. They would stream to an
enterprise logging system where 10,000 error messages are supposed to go.</p>
<p>Recoverable would still participate in destruction and scram. Youâ€™d have
to wonder if a recoverable fails due to scram, does that get logged or
does it get reported by the root? It it is a self-scram, logging seems to
be obviously the responsibilty of whoever made it <code>recoverable</code>. If it is
a root-scram it is less obviously the responsibility of whoever made it
<code>recoverable</code>.</p>
<p>So, <code>recoverable</code> is probably the solution and not <code>rescue</code>, and I have
no use for <code>rescue</code> in the current database work that Iâ€™m doing.</p>

            </div>

        </li>


        <li id="section-122">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-122">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>    rescue (...vargs) {
        <span class="hljs-keyword">const</span> f = vargs.pop()
        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">async</span> () =&gt; {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">typeof</span> f == <span class="hljs-string">&#x27;function&#x27;</span> ? f() : f)
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">if</span> (error.instance !== <span class="hljs-built_in">this</span>._properties.instance) {</pre></div></div>

        </li>


        <li id="section-123">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-123">&#182;</a>
              </div>
              <p><strong>TODO</strong> Shouldnâ€™t we set <code>errored</code> here?</p>

            </div>

            <div class="content"><div class='highlight'><pre>                    <span class="hljs-built_in">this</span>._tracer.push({ <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;rescue&#x27;</span>, <span class="hljs-attr">errored</span>: <span class="hljs-built_in">this</span>._isolation.errored, <span class="hljs-attr">path</span>: <span class="hljs-built_in">this</span>.path })
                    <span class="hljs-built_in">this</span>._countdown = <span class="hljs-number">0</span>
                    <span class="hljs-built_in">this</span>._destroy()
                    <span class="hljs-keyword">throw</span> error
                }
            }
        }) ()
    }
}

<span class="hljs-built_in">module</span>.exports = Destructible</pre></div></div>

        </li>

    </ul>
  </div>
</body>
</html>
