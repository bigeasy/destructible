<!DOCTYPE html>
<html>
  <meta charset="utf-8">
  <title>Destructible</title>
  <link href="https://fonts.googleapis.com/css?family=Cutive+Mono|Sorts+Mill+Goudy|Mate|Oxygen+Mono|Offside|Raleway:400,700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Sorts+Mill+Goudy">
  <link rel="stylesheet" type="text/css" href="css/ascetic.css">
  <link rel="stylesheet" type="text/css" href="css/style.css">
</html>
<body><a href="https://github.com/bigeasy/destructible/"><img style="position: fixed; top: 0; left: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_gray_6d6d6d.png" alt="Fork me on GitHub"></a>
  <div class="container">
    <div class="unit welcome">
      <h1>Destructible</h1>
      <!-- todo: code font is too small for body text font-->
    </div>
    <div class="unit description markdown include" data-file="index.md"><p>Look at the <a href="./docco/">Docco</a> for now.</p>
<h2 id="on-breaking-things">On Breaking Things</h2>
<p>I&apos;ve chased a problem to a crossroads. The problem is how to propagate errors
from parallel asynchronous stacks. You may have two separate streams that you
need to monitor for events, for example. You might spawn a child process and
listen to it&apos;s standard out. Waiting for messages on standard out is separate
from waiting for exit.</p>
<p>Cadence doesn&apos;t have a timeout. When you create parallel sub-cadences, the
function will not return until both Cadences complete.</p>
<pre><code>cadence(function (async) {
    async(function () {
        var loop = async(function () {
            input.get(async())
        }, function (value) {
            if (value == null) {
                return [ loop.break ]
            }
            consumer.consume(value, async())
        })()
    })
    async(function () {
        input.closed(async())
    })
})(abend)
</code></pre><p>In our program, we want to wait for input close because it may report an error
to us. We also want to get things from input, which may also error, our little
pump loop may error.</p>
<p>If input gives us a closed event we would expect get to error. If get errors we
would expect to have input close. This is what we gleaned from reading the
documenation for the <code>input</code> class.</p>
<p>We need a mechanism that will timeout the function with an error if the loop
exits but closed is never called or if closed is called but the loop never
exits.</p>
<p>There is no good way for cadence to know how long something is supposed to run.
There is no good assumption as to how long something is supposed to run relative
to something else. There are no assumptions</p>
<pre><code>cadence(function (async) {
    var deststuctiable = new Destructible(&apos;pump&apos;)
    deststuctiable.monitor(&apos;loop&apos;, this, cadence(function (async) {
        var loop = async(function () {
            input.get(async())
        }, function (value) {
            if (value == null) {
                return [ loop.break ]
            }
            consumer.consume(value, async())
        })()
    }))
    deststuctiable.monitor(&apos;loop&apos;, this, cadence(function (async) {
        input.closed(async())
    }))
    deststuctiable.completed(10000, async())
})(function (error, closed) {
    if (error) throw error
    console.log(&apos;closed with status: &apos; + closed)
})
</code></pre><p>I don&apos;t like that I&apos;m about to repeat an implementation of the ordered results
in Cadence in Destructible, but it does make Destructible not so Cadence
specific. The alternative is Cadence-aware.</p>
<pre><code>cadence(function (async) {
    var deststuctiable = new Destructible(&apos;pump&apos;)
    deststuctiable.completed(10000, async())
    deststuctiable.monitor(async, &apos;loop&apos;)(function () {
        var loop = async(function () {
            input.get(async())
        }, function (value) {
            if (value == null) {
                return [ loop.break ]
            }
            consumer.consume(value, async())
        })()
    })
    deststuctiable.monitor(async, &apos;loop&apos;)(function () {
        input.closed(async())
    })
})(function (error, closed) {
    if (error) throw error
    console.log(&apos;closed with status: &apos; + closed)
})
</code></pre><p>The above requires a modification to Cadence where Cadence does not return the
first error it catches but instead returns the errors in the order in which they
are declared so that if there is a hang up, the wrapped exception gets reported.</p>
<p>The problem with this one is that if there is a hangup, there is still now way
to stop the nested Cadences. It won&apos;t return. This could be expressed as such.</p>
<pre><code>cadence(function (async) {
    var deststuctiable = new Destructible(&apos;pump&apos;)
    deststuctiable.monitor(async, &apos;loop&apos;)(function () {
        var loop = async(function () {
            input.get(async())
        }, function (value) {
            if (value == null) {
                return [ loop.break ]
            }
            consumer.consume(value, async())
        })()
    })
    deststuctiable.monitor(async, &apos;loop&apos;)(function () {
        input.closed(async())
    })
    deststuctiable.timeout(10000)
})(function (error, closed) {
    if (error) throw error
    console.log(&apos;closed with status: &apos; + closed)
})
</code></pre><p>Here the timeout is catastrophic. It would cause an exception to be raised that
cannot be caught. It ends up being similar to our terminator class, but built
in. With this we surrender the notion of funneling exceptions upward and maybe
we should because...</p>
<p>A stuck stack is catastrophic. You can wait for it to finish, but maybe it is
going to be a while, like maybe forever.</p>
<p>You&apos;ve given a callack to ??? and it is not getting called back. You either wait
or if you timeout you now have to deal with a leak.</p>
<p>A leak!</p>
<p>OR</p>
<p>You&apos;re dealing with a callback that will be called eventually. When that happens
what do you do with the result? You&apos;ve timed out, moved on. You reported an
error to your callee. No one is listening. No one to return to.</p>
<p>And what if you&apos;re callback receives an error? At that point you abend.</p>
<p>Thus, the only reasonable result is to abend.</p>
<pre><code>cadence(function (async) {
    var deststuctiable = new Destructible(&apos;pump&apos;)
    deststuctiable.monitor(&apos;loop&apos;, this, cadence(function (async) {
        var loop = async(function () {
            input.get(async())
        }, function (value) {
            if (value == null) {
                return [ loop.break ]
            }
            consumer.consume(value, async())
        })()
    }))
    deststuctiable.monitor(async, &apos;loop&apos;)(function () {
        input.closed(async())
    })
    deststuctiable.timeout(10000)
})(function (error, closed) {
    if (error) throw error
    console.log(&apos;closed with status: &apos; + closed)
})
</code></pre><p>That is the easy-for-me Cadence way.</p>
<pre><code>cadence(function (async) {
    var deststuctiable = new Destructible(&apos;pump&apos;)
    deststuctiable.monitor(&apos;loop&apos;, this, cadence(function (async) {
        var loop = async(function () {
            input.get(async())
        }, function (value) {
            if (value == null) {
                return [ loop.break ]
            }
            consumer.consume(value, async())
        })()
    }))
    deststuctiable.monitor(&apos;loop&apos;, function (callback) {
        input.closed(callback)
    })
    deststuctiable.timeout(10000, async())
})(function (error, closed) {
    if (error) throw error
    console.log(&apos;closed with status: &apos; + closed)
})
</code></pre><p>Could we just build this into Cadence?</p>
<pre><code>cadence(function (async) {
    async.shutdown(1000)
    async(function () {
        var loop = async(function () {
            input.get(async())
        }, function (value) {
            if (value == null) {
                return [ loop.break ]
            }
            consumer.consume(value, async())
        })()
    })
    async(function () {
        input.closed(async())
    })
})(abend)
</code></pre><p>Because it is such a sticking point. It is the bit left out. Destructible still
has the destructors, though.</p>
<pre><code>cadence(function (async) {
    async.shutdown(1000)
    async(function () {
        async.loop(function () {
            input.get(async())
        }, function (value) {
            if (value == null) {
                return [ async.break ]
            }
            consumer.consume(value, async())
        })
    })
    async(function () {
        input.closed(async())
    })
})(abend)
</code></pre><p>Don&apos;t get so melodramatic about the missed callbacks. You could also miss them
if you raise an exception after creating a callback.</p>
<p><strong>MAYBE</strong>: The only way to do this is to preserve the boundary.</p>
<p>Thus, destructor generates callbacks. It does preserve the results and return
them. This ends up duplicated Cadence a bit. Not sure how you would go about
implementing Rescue. Ah, with a callback, too.</p>
<p>Because the wrapping appears to be no end of trouble as far as propagation goes,
and the special activities with someone else&apos;s <code>async</code> are way to tricky.</p>
<ul>
<li>Implies that this is some sort of inside-out Cadence, which makes you want to
seek a Cadence decorator.</li>
<li>Removes the nice and clean implementations you imagined, using closures, but
it ought to be easier to see what is going on.</li>
<li>Always wait for completed, gather your results there, or else get your error.</li>
</ul>
<p>Wrapping is causing a lot of architecture to appear, so before you walk away
from wrapping, you&apos;re going to want to know why it didn&apos;t work.</p>
<ul>
<li>What did wrapping add to complexity to cause Cadence to catch use exceptions?</li>
<li>What would it take to make that go away?</li>
<li>Is there a way to do the <code>async</code> trick generally, and not bake it into
libraries specifically?</li>
<li>The use of <code>async</code> trick in Compassion is fooling you in Destructible.</li>
<li>Can I remove <code>monitor</code> without affecting Staccato?</li>
</ul>
<p>The problem is in calling unwind and that, in turn, calling the completion
Signal, which resumes running before everything is really wound down.</p>
<p>Why? This means that arbitrary callbacks are being fired. The destructors. These
are generally causing other stacks to unwind, so that is not going to often be
an issue. But when the last one unwinds it triggers continued action.</p>
<p>Thus, we call this completed function and resume from within a destructor that
has it&apos;s own callback that will catch an error thrown from the resumed code.
We&apos;re invoking from within Cadence.</p>
<p>We could use nextTick, but we haven&apos;t yet. All this would change if we embraced
it.</p>
<p>Destructable becomes some sort of countdown latch, then. Doesn&apos;t really require
a deep rethink of Cadence.</p>
<p>Your program will exit because there is no work in the event loop, but you&apos;re
stack trace does not appear because something didn&apos;t completely wind down.</p>
</div>
  </div>
  <!-- todo: move into an edify plugin-->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-20388260-3', 'bigeasy.github.io');
    ga('send', 'pageview');
  </script>
</body>
<!-- vim: set ts=2 sw=2 nowrap:-->
